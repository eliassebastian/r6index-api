// Code generated by msgpackgen. DO NOT EDIT.

package models

import (
	"fmt"
	msgpack "github.com/shamaton/msgpackgen/msgpack"
	dec "github.com/shamaton/msgpackgen/msgpack/dec"
	enc "github.com/shamaton/msgpackgen/msgpack/enc"
	"time"
)

// RegisterGeneratedResolver registers generated resolver.
func RegisterGeneratedResolver() {
	msgpack.SetResolver(___encodeAsMap, ___encodeAsArray, ___decodeAsMap, ___decodeAsArray)
}

// encode
func ___encode(i interface{}) ([]byte, error) {
	if msgpack.StructAsArray() {
		return ___encodeAsArray(i)
	} else {
		return ___encodeAsMap(i)
	}
}

// encodeAsArray
func ___encodeAsArray(i interface{}) ([]byte, error) {
	switch v := i.(type) {
	case AliasCache:
		encoder := enc.NewEncoder()
		size, err := ___calcArraySizeAliasCache_de2aaf9f1c3e6e79572ba1d8fcf368e421faacf20f265a5b663a07b0680ffe2d(v, encoder)
		if err != nil {
			return nil, err
		}
		encoder.MakeBytes(size)
		b, offset, err := ___encodeArrayAliasCache_de2aaf9f1c3e6e79572ba1d8fcf368e421faacf20f265a5b663a07b0680ffe2d(v, encoder, 0)
		if err != nil {
			return nil, err
		}
		if size != offset {
			return nil, fmt.Errorf("%s size / offset different %d : %d", "AliasCache", size, offset)
		}
		return b, err
	case *AliasCache:
		encoder := enc.NewEncoder()
		size, err := ___calcArraySizeAliasCache_de2aaf9f1c3e6e79572ba1d8fcf368e421faacf20f265a5b663a07b0680ffe2d(*v, encoder)
		if err != nil {
			return nil, err
		}
		encoder.MakeBytes(size)
		b, offset, err := ___encodeArrayAliasCache_de2aaf9f1c3e6e79572ba1d8fcf368e421faacf20f265a5b663a07b0680ffe2d(*v, encoder, 0)
		if err != nil {
			return nil, err
		}
		if size != offset {
			return nil, fmt.Errorf("%s size / offset different %d : %d", "AliasCache", size, offset)
		}
		return b, err
	case Alias:
		encoder := enc.NewEncoder()
		size, err := ___calcArraySizeAlias_de2aaf9f1c3e6e79572ba1d8fcf368e421faacf20f265a5b663a07b0680ffe2d(v, encoder)
		if err != nil {
			return nil, err
		}
		encoder.MakeBytes(size)
		b, offset, err := ___encodeArrayAlias_de2aaf9f1c3e6e79572ba1d8fcf368e421faacf20f265a5b663a07b0680ffe2d(v, encoder, 0)
		if err != nil {
			return nil, err
		}
		if size != offset {
			return nil, fmt.Errorf("%s size / offset different %d : %d", "Alias", size, offset)
		}
		return b, err
	case *Alias:
		encoder := enc.NewEncoder()
		size, err := ___calcArraySizeAlias_de2aaf9f1c3e6e79572ba1d8fcf368e421faacf20f265a5b663a07b0680ffe2d(*v, encoder)
		if err != nil {
			return nil, err
		}
		encoder.MakeBytes(size)
		b, offset, err := ___encodeArrayAlias_de2aaf9f1c3e6e79572ba1d8fcf368e421faacf20f265a5b663a07b0680ffe2d(*v, encoder, 0)
		if err != nil {
			return nil, err
		}
		if size != offset {
			return nil, fmt.Errorf("%s size / offset different %d : %d", "Alias", size, offset)
		}
		return b, err
	case ProfileCache:
		encoder := enc.NewEncoder()
		size, err := ___calcArraySizeProfileCache_de2aaf9f1c3e6e79572ba1d8fcf368e421faacf20f265a5b663a07b0680ffe2d(v, encoder)
		if err != nil {
			return nil, err
		}
		encoder.MakeBytes(size)
		b, offset, err := ___encodeArrayProfileCache_de2aaf9f1c3e6e79572ba1d8fcf368e421faacf20f265a5b663a07b0680ffe2d(v, encoder, 0)
		if err != nil {
			return nil, err
		}
		if size != offset {
			return nil, fmt.Errorf("%s size / offset different %d : %d", "ProfileCache", size, offset)
		}
		return b, err
	case *ProfileCache:
		encoder := enc.NewEncoder()
		size, err := ___calcArraySizeProfileCache_de2aaf9f1c3e6e79572ba1d8fcf368e421faacf20f265a5b663a07b0680ffe2d(*v, encoder)
		if err != nil {
			return nil, err
		}
		encoder.MakeBytes(size)
		b, offset, err := ___encodeArrayProfileCache_de2aaf9f1c3e6e79572ba1d8fcf368e421faacf20f265a5b663a07b0680ffe2d(*v, encoder, 0)
		if err != nil {
			return nil, err
		}
		if size != offset {
			return nil, fmt.Errorf("%s size / offset different %d : %d", "ProfileCache", size, offset)
		}
		return b, err
	case PlayerFound:
		encoder := enc.NewEncoder()
		size, err := ___calcArraySizePlayerFound_de2aaf9f1c3e6e79572ba1d8fcf368e421faacf20f265a5b663a07b0680ffe2d(v, encoder)
		if err != nil {
			return nil, err
		}
		encoder.MakeBytes(size)
		b, offset, err := ___encodeArrayPlayerFound_de2aaf9f1c3e6e79572ba1d8fcf368e421faacf20f265a5b663a07b0680ffe2d(v, encoder, 0)
		if err != nil {
			return nil, err
		}
		if size != offset {
			return nil, fmt.Errorf("%s size / offset different %d : %d", "PlayerFound", size, offset)
		}
		return b, err
	case *PlayerFound:
		encoder := enc.NewEncoder()
		size, err := ___calcArraySizePlayerFound_de2aaf9f1c3e6e79572ba1d8fcf368e421faacf20f265a5b663a07b0680ffe2d(*v, encoder)
		if err != nil {
			return nil, err
		}
		encoder.MakeBytes(size)
		b, offset, err := ___encodeArrayPlayerFound_de2aaf9f1c3e6e79572ba1d8fcf368e421faacf20f265a5b663a07b0680ffe2d(*v, encoder, 0)
		if err != nil {
			return nil, err
		}
		if size != offset {
			return nil, fmt.Errorf("%s size / offset different %d : %d", "PlayerFound", size, offset)
		}
		return b, err
	}
	return nil, nil
}

// encodeAsMap
func ___encodeAsMap(i interface{}) ([]byte, error) {
	switch v := i.(type) {
	case AliasCache:
		encoder := enc.NewEncoder()
		size, err := ___calcMapSizeAliasCache_de2aaf9f1c3e6e79572ba1d8fcf368e421faacf20f265a5b663a07b0680ffe2d(v, encoder)
		if err != nil {
			return nil, err
		}
		encoder.MakeBytes(size)
		b, offset, err := ___encodeMapAliasCache_de2aaf9f1c3e6e79572ba1d8fcf368e421faacf20f265a5b663a07b0680ffe2d(v, encoder, 0)
		if err != nil {
			return nil, err
		}
		if size != offset {
			return nil, fmt.Errorf("%s size / offset different %d : %d", "AliasCache", size, offset)
		}
		return b, err
	case *AliasCache:
		encoder := enc.NewEncoder()
		size, err := ___calcMapSizeAliasCache_de2aaf9f1c3e6e79572ba1d8fcf368e421faacf20f265a5b663a07b0680ffe2d(*v, encoder)
		if err != nil {
			return nil, err
		}
		encoder.MakeBytes(size)
		b, offset, err := ___encodeMapAliasCache_de2aaf9f1c3e6e79572ba1d8fcf368e421faacf20f265a5b663a07b0680ffe2d(*v, encoder, 0)
		if err != nil {
			return nil, err
		}
		if size != offset {
			return nil, fmt.Errorf("%s size / offset different %d : %d", "AliasCache", size, offset)
		}
		return b, err
	case Alias:
		encoder := enc.NewEncoder()
		size, err := ___calcMapSizeAlias_de2aaf9f1c3e6e79572ba1d8fcf368e421faacf20f265a5b663a07b0680ffe2d(v, encoder)
		if err != nil {
			return nil, err
		}
		encoder.MakeBytes(size)
		b, offset, err := ___encodeMapAlias_de2aaf9f1c3e6e79572ba1d8fcf368e421faacf20f265a5b663a07b0680ffe2d(v, encoder, 0)
		if err != nil {
			return nil, err
		}
		if size != offset {
			return nil, fmt.Errorf("%s size / offset different %d : %d", "Alias", size, offset)
		}
		return b, err
	case *Alias:
		encoder := enc.NewEncoder()
		size, err := ___calcMapSizeAlias_de2aaf9f1c3e6e79572ba1d8fcf368e421faacf20f265a5b663a07b0680ffe2d(*v, encoder)
		if err != nil {
			return nil, err
		}
		encoder.MakeBytes(size)
		b, offset, err := ___encodeMapAlias_de2aaf9f1c3e6e79572ba1d8fcf368e421faacf20f265a5b663a07b0680ffe2d(*v, encoder, 0)
		if err != nil {
			return nil, err
		}
		if size != offset {
			return nil, fmt.Errorf("%s size / offset different %d : %d", "Alias", size, offset)
		}
		return b, err
	case ProfileCache:
		encoder := enc.NewEncoder()
		size, err := ___calcMapSizeProfileCache_de2aaf9f1c3e6e79572ba1d8fcf368e421faacf20f265a5b663a07b0680ffe2d(v, encoder)
		if err != nil {
			return nil, err
		}
		encoder.MakeBytes(size)
		b, offset, err := ___encodeMapProfileCache_de2aaf9f1c3e6e79572ba1d8fcf368e421faacf20f265a5b663a07b0680ffe2d(v, encoder, 0)
		if err != nil {
			return nil, err
		}
		if size != offset {
			return nil, fmt.Errorf("%s size / offset different %d : %d", "ProfileCache", size, offset)
		}
		return b, err
	case *ProfileCache:
		encoder := enc.NewEncoder()
		size, err := ___calcMapSizeProfileCache_de2aaf9f1c3e6e79572ba1d8fcf368e421faacf20f265a5b663a07b0680ffe2d(*v, encoder)
		if err != nil {
			return nil, err
		}
		encoder.MakeBytes(size)
		b, offset, err := ___encodeMapProfileCache_de2aaf9f1c3e6e79572ba1d8fcf368e421faacf20f265a5b663a07b0680ffe2d(*v, encoder, 0)
		if err != nil {
			return nil, err
		}
		if size != offset {
			return nil, fmt.Errorf("%s size / offset different %d : %d", "ProfileCache", size, offset)
		}
		return b, err
	case PlayerFound:
		encoder := enc.NewEncoder()
		size, err := ___calcMapSizePlayerFound_de2aaf9f1c3e6e79572ba1d8fcf368e421faacf20f265a5b663a07b0680ffe2d(v, encoder)
		if err != nil {
			return nil, err
		}
		encoder.MakeBytes(size)
		b, offset, err := ___encodeMapPlayerFound_de2aaf9f1c3e6e79572ba1d8fcf368e421faacf20f265a5b663a07b0680ffe2d(v, encoder, 0)
		if err != nil {
			return nil, err
		}
		if size != offset {
			return nil, fmt.Errorf("%s size / offset different %d : %d", "PlayerFound", size, offset)
		}
		return b, err
	case *PlayerFound:
		encoder := enc.NewEncoder()
		size, err := ___calcMapSizePlayerFound_de2aaf9f1c3e6e79572ba1d8fcf368e421faacf20f265a5b663a07b0680ffe2d(*v, encoder)
		if err != nil {
			return nil, err
		}
		encoder.MakeBytes(size)
		b, offset, err := ___encodeMapPlayerFound_de2aaf9f1c3e6e79572ba1d8fcf368e421faacf20f265a5b663a07b0680ffe2d(*v, encoder, 0)
		if err != nil {
			return nil, err
		}
		if size != offset {
			return nil, fmt.Errorf("%s size / offset different %d : %d", "PlayerFound", size, offset)
		}
		return b, err
	}
	return nil, nil
}

// decode
func ___decode(data []byte, i interface{}) (bool, error) {
	if msgpack.StructAsArray() {
		return ___decodeAsArray(data, i)
	} else {
		return ___decodeAsMap(data, i)
	}
}

// decodeAsArray
func ___decodeAsArray(data []byte, i interface{}) (bool, error) {
	switch v := i.(type) {
	case *AliasCache:
		decoder := dec.NewDecoder(data)
		offset, err := ___decodeArrayAliasCache_de2aaf9f1c3e6e79572ba1d8fcf368e421faacf20f265a5b663a07b0680ffe2d(v, decoder, 0)
		if err == nil && offset != decoder.Len() {
			return true, fmt.Errorf("read length is different [%d] [%d] ", offset, decoder.Len())
		}
		return true, err
	case **AliasCache:
		decoder := dec.NewDecoder(data)
		offset, err := ___decodeArrayAliasCache_de2aaf9f1c3e6e79572ba1d8fcf368e421faacf20f265a5b663a07b0680ffe2d(*v, decoder, 0)
		if err == nil && offset != decoder.Len() {
			return true, fmt.Errorf("read length is different [%d] [%d] ", offset, decoder.Len())
		}
		return true, err
	case *Alias:
		decoder := dec.NewDecoder(data)
		offset, err := ___decodeArrayAlias_de2aaf9f1c3e6e79572ba1d8fcf368e421faacf20f265a5b663a07b0680ffe2d(v, decoder, 0)
		if err == nil && offset != decoder.Len() {
			return true, fmt.Errorf("read length is different [%d] [%d] ", offset, decoder.Len())
		}
		return true, err
	case **Alias:
		decoder := dec.NewDecoder(data)
		offset, err := ___decodeArrayAlias_de2aaf9f1c3e6e79572ba1d8fcf368e421faacf20f265a5b663a07b0680ffe2d(*v, decoder, 0)
		if err == nil && offset != decoder.Len() {
			return true, fmt.Errorf("read length is different [%d] [%d] ", offset, decoder.Len())
		}
		return true, err
	case *ProfileCache:
		decoder := dec.NewDecoder(data)
		offset, err := ___decodeArrayProfileCache_de2aaf9f1c3e6e79572ba1d8fcf368e421faacf20f265a5b663a07b0680ffe2d(v, decoder, 0)
		if err == nil && offset != decoder.Len() {
			return true, fmt.Errorf("read length is different [%d] [%d] ", offset, decoder.Len())
		}
		return true, err
	case **ProfileCache:
		decoder := dec.NewDecoder(data)
		offset, err := ___decodeArrayProfileCache_de2aaf9f1c3e6e79572ba1d8fcf368e421faacf20f265a5b663a07b0680ffe2d(*v, decoder, 0)
		if err == nil && offset != decoder.Len() {
			return true, fmt.Errorf("read length is different [%d] [%d] ", offset, decoder.Len())
		}
		return true, err
	case *PlayerFound:
		decoder := dec.NewDecoder(data)
		offset, err := ___decodeArrayPlayerFound_de2aaf9f1c3e6e79572ba1d8fcf368e421faacf20f265a5b663a07b0680ffe2d(v, decoder, 0)
		if err == nil && offset != decoder.Len() {
			return true, fmt.Errorf("read length is different [%d] [%d] ", offset, decoder.Len())
		}
		return true, err
	case **PlayerFound:
		decoder := dec.NewDecoder(data)
		offset, err := ___decodeArrayPlayerFound_de2aaf9f1c3e6e79572ba1d8fcf368e421faacf20f265a5b663a07b0680ffe2d(*v, decoder, 0)
		if err == nil && offset != decoder.Len() {
			return true, fmt.Errorf("read length is different [%d] [%d] ", offset, decoder.Len())
		}
		return true, err
	}
	return false, nil
}

// decodeAsMap
func ___decodeAsMap(data []byte, i interface{}) (bool, error) {
	switch v := i.(type) {
	case *AliasCache:
		decoder := dec.NewDecoder(data)
		offset, err := ___decodeMapAliasCache_de2aaf9f1c3e6e79572ba1d8fcf368e421faacf20f265a5b663a07b0680ffe2d(v, decoder, 0)
		if err == nil && offset != decoder.Len() {
			return true, fmt.Errorf("read length is different [%d] [%d] ", offset, decoder.Len())
		}
		return true, err
	case **AliasCache:
		decoder := dec.NewDecoder(data)
		offset, err := ___decodeMapAliasCache_de2aaf9f1c3e6e79572ba1d8fcf368e421faacf20f265a5b663a07b0680ffe2d(*v, decoder, 0)
		if err == nil && offset != decoder.Len() {
			return true, fmt.Errorf("read length is different [%d] [%d] ", offset, decoder.Len())
		}
		return true, err
	case *Alias:
		decoder := dec.NewDecoder(data)
		offset, err := ___decodeMapAlias_de2aaf9f1c3e6e79572ba1d8fcf368e421faacf20f265a5b663a07b0680ffe2d(v, decoder, 0)
		if err == nil && offset != decoder.Len() {
			return true, fmt.Errorf("read length is different [%d] [%d] ", offset, decoder.Len())
		}
		return true, err
	case **Alias:
		decoder := dec.NewDecoder(data)
		offset, err := ___decodeMapAlias_de2aaf9f1c3e6e79572ba1d8fcf368e421faacf20f265a5b663a07b0680ffe2d(*v, decoder, 0)
		if err == nil && offset != decoder.Len() {
			return true, fmt.Errorf("read length is different [%d] [%d] ", offset, decoder.Len())
		}
		return true, err
	case *ProfileCache:
		decoder := dec.NewDecoder(data)
		offset, err := ___decodeMapProfileCache_de2aaf9f1c3e6e79572ba1d8fcf368e421faacf20f265a5b663a07b0680ffe2d(v, decoder, 0)
		if err == nil && offset != decoder.Len() {
			return true, fmt.Errorf("read length is different [%d] [%d] ", offset, decoder.Len())
		}
		return true, err
	case **ProfileCache:
		decoder := dec.NewDecoder(data)
		offset, err := ___decodeMapProfileCache_de2aaf9f1c3e6e79572ba1d8fcf368e421faacf20f265a5b663a07b0680ffe2d(*v, decoder, 0)
		if err == nil && offset != decoder.Len() {
			return true, fmt.Errorf("read length is different [%d] [%d] ", offset, decoder.Len())
		}
		return true, err
	case *PlayerFound:
		decoder := dec.NewDecoder(data)
		offset, err := ___decodeMapPlayerFound_de2aaf9f1c3e6e79572ba1d8fcf368e421faacf20f265a5b663a07b0680ffe2d(v, decoder, 0)
		if err == nil && offset != decoder.Len() {
			return true, fmt.Errorf("read length is different [%d] [%d] ", offset, decoder.Len())
		}
		return true, err
	case **PlayerFound:
		decoder := dec.NewDecoder(data)
		offset, err := ___decodeMapPlayerFound_de2aaf9f1c3e6e79572ba1d8fcf368e421faacf20f265a5b663a07b0680ffe2d(*v, decoder, 0)
		if err == nil && offset != decoder.Len() {
			return true, fmt.Errorf("read length is different [%d] [%d] ", offset, decoder.Len())
		}
		return true, err
	}
	return false, nil
}

// calculate size from github.com/eliassebastian/r6index-api/cmd/api/models.AliasCache
func ___calcArraySizeAliasCache_de2aaf9f1c3e6e79572ba1d8fcf368e421faacf20f265a5b663a07b0680ffe2d(v AliasCache, encoder *enc.Encoder) (int, error) {
	size := 0
	size += encoder.CalcStructHeaderFix(2)
	size += encoder.CalcString(v.Name)
	size += encoder.CalcTime(v.LastUpdate)
	return size, nil
}

// calculate size from github.com/eliassebastian/r6index-api/cmd/api/models.AliasCache
func ___calcMapSizeAliasCache_de2aaf9f1c3e6e79572ba1d8fcf368e421faacf20f265a5b663a07b0680ffe2d(v AliasCache, encoder *enc.Encoder) (int, error) {
	size := 0
	size += encoder.CalcStructHeaderFix(2)
	size += encoder.CalcStringFix(4)
	size += encoder.CalcString(v.Name)
	size += encoder.CalcStringFix(10)
	size += encoder.CalcTime(v.LastUpdate)
	return size, nil
}

// encode from github.com/eliassebastian/r6index-api/cmd/api/models.AliasCache
func ___encodeArrayAliasCache_de2aaf9f1c3e6e79572ba1d8fcf368e421faacf20f265a5b663a07b0680ffe2d(v AliasCache, encoder *enc.Encoder, offset int) ([]byte, int, error) {
	var err error
	offset = encoder.WriteStructHeaderFixAsArray(2, offset)
	offset = encoder.WriteString(v.Name, offset)
	offset = encoder.WriteTime(v.LastUpdate, offset)
	return encoder.EncodedBytes(), offset, err
}

// encode from github.com/eliassebastian/r6index-api/cmd/api/models.AliasCache
func ___encodeMapAliasCache_de2aaf9f1c3e6e79572ba1d8fcf368e421faacf20f265a5b663a07b0680ffe2d(v AliasCache, encoder *enc.Encoder, offset int) ([]byte, int, error) {
	var err error
	offset = encoder.WriteStructHeaderFixAsMap(2, offset)
	offset = encoder.WriteStringFix("Name", 4, offset)
	offset = encoder.WriteString(v.Name, offset)
	offset = encoder.WriteStringFix("LastUpdate", 10, offset)
	offset = encoder.WriteTime(v.LastUpdate, offset)
	return encoder.EncodedBytes(), offset, err
}

// decode to github.com/eliassebastian/r6index-api/cmd/api/models.AliasCache
func ___decodeArrayAliasCache_de2aaf9f1c3e6e79572ba1d8fcf368e421faacf20f265a5b663a07b0680ffe2d(v *AliasCache, decoder *dec.Decoder, offset int) (int, error) {
	offset, err := decoder.CheckStructHeader(2, offset)
	if err != nil {
		return 0, err
	}
	{
		var vv string
		vv, offset, err = decoder.AsString(offset)
		if err != nil {
			return 0, err
		}
		v.Name = vv
	}
	{
		var vv time.Time
		vv, offset, err = decoder.AsDateTime(offset)
		if err != nil {
			return 0, err
		}
		v.LastUpdate = vv
	}
	return offset, err
}

// decode to github.com/eliassebastian/r6index-api/cmd/api/models.AliasCache
func ___decodeMapAliasCache_de2aaf9f1c3e6e79572ba1d8fcf368e421faacf20f265a5b663a07b0680ffe2d(v *AliasCache, decoder *dec.Decoder, offset int) (int, error) {
	keys := [][]byte{
		{uint8(0x4e), uint8(0x61), uint8(0x6d), uint8(0x65)},                                                                               // Name
		{uint8(0x4c), uint8(0x61), uint8(0x73), uint8(0x74), uint8(0x55), uint8(0x70), uint8(0x64), uint8(0x61), uint8(0x74), uint8(0x65)}, // LastUpdate
	}
	offset, err := decoder.CheckStructHeader(2, offset)
	if err != nil {
		return 0, err
	}
	count := 0
	for count < 2 {
		var dataKey []byte
		dataKey, offset, err = decoder.AsStringBytes(offset)
		if err != nil {
			return 0, err
		}
		fieldIndex := -1
		for i, key := range keys {
			if len(dataKey) != len(key) {
				continue
			}
			fieldIndex = i
			for dataKeyIndex := range dataKey {
				if dataKey[dataKeyIndex] != key[dataKeyIndex] {
					fieldIndex = -1
					break
				}
			}
			if fieldIndex >= 0 {
				break
			}
		}
		switch fieldIndex {
		case 0:
			{
				var vv string
				vv, offset, err = decoder.AsString(offset)
				if err != nil {
					return 0, err
				}
				v.Name = vv
			}
			count++
		case 1:
			{
				var vv time.Time
				vv, offset, err = decoder.AsDateTime(offset)
				if err != nil {
					return 0, err
				}
				v.LastUpdate = vv
			}
			count++
		default:
			return 0, fmt.Errorf("unknown key[%s] found", string(dataKey))
		}
	}
	return offset, err
}

// calculate size from github.com/eliassebastian/r6index-api/cmd/api/models.Alias
func ___calcArraySizeAlias_de2aaf9f1c3e6e79572ba1d8fcf368e421faacf20f265a5b663a07b0680ffe2d(v Alias, encoder *enc.Encoder) (int, error) {
	size := 0
	size += encoder.CalcStructHeaderFix(2)
	size += encoder.CalcString(v.Name)
	size += encoder.CalcTime(v.Date)
	return size, nil
}

// calculate size from github.com/eliassebastian/r6index-api/cmd/api/models.Alias
func ___calcMapSizeAlias_de2aaf9f1c3e6e79572ba1d8fcf368e421faacf20f265a5b663a07b0680ffe2d(v Alias, encoder *enc.Encoder) (int, error) {
	size := 0
	size += encoder.CalcStructHeaderFix(2)
	size += encoder.CalcStringFix(4)
	size += encoder.CalcString(v.Name)
	size += encoder.CalcStringFix(4)
	size += encoder.CalcTime(v.Date)
	return size, nil
}

// encode from github.com/eliassebastian/r6index-api/cmd/api/models.Alias
func ___encodeArrayAlias_de2aaf9f1c3e6e79572ba1d8fcf368e421faacf20f265a5b663a07b0680ffe2d(v Alias, encoder *enc.Encoder, offset int) ([]byte, int, error) {
	var err error
	offset = encoder.WriteStructHeaderFixAsArray(2, offset)
	offset = encoder.WriteString(v.Name, offset)
	offset = encoder.WriteTime(v.Date, offset)
	return encoder.EncodedBytes(), offset, err
}

// encode from github.com/eliassebastian/r6index-api/cmd/api/models.Alias
func ___encodeMapAlias_de2aaf9f1c3e6e79572ba1d8fcf368e421faacf20f265a5b663a07b0680ffe2d(v Alias, encoder *enc.Encoder, offset int) ([]byte, int, error) {
	var err error
	offset = encoder.WriteStructHeaderFixAsMap(2, offset)
	offset = encoder.WriteStringFix("Name", 4, offset)
	offset = encoder.WriteString(v.Name, offset)
	offset = encoder.WriteStringFix("Date", 4, offset)
	offset = encoder.WriteTime(v.Date, offset)
	return encoder.EncodedBytes(), offset, err
}

// decode to github.com/eliassebastian/r6index-api/cmd/api/models.Alias
func ___decodeArrayAlias_de2aaf9f1c3e6e79572ba1d8fcf368e421faacf20f265a5b663a07b0680ffe2d(v *Alias, decoder *dec.Decoder, offset int) (int, error) {
	offset, err := decoder.CheckStructHeader(2, offset)
	if err != nil {
		return 0, err
	}
	{
		var vv string
		vv, offset, err = decoder.AsString(offset)
		if err != nil {
			return 0, err
		}
		v.Name = vv
	}
	{
		var vv time.Time
		vv, offset, err = decoder.AsDateTime(offset)
		if err != nil {
			return 0, err
		}
		v.Date = vv
	}
	return offset, err
}

// decode to github.com/eliassebastian/r6index-api/cmd/api/models.Alias
func ___decodeMapAlias_de2aaf9f1c3e6e79572ba1d8fcf368e421faacf20f265a5b663a07b0680ffe2d(v *Alias, decoder *dec.Decoder, offset int) (int, error) {
	keys := [][]byte{
		{uint8(0x4e), uint8(0x61), uint8(0x6d), uint8(0x65)}, // Name
		{uint8(0x44), uint8(0x61), uint8(0x74), uint8(0x65)}, // Date
	}
	offset, err := decoder.CheckStructHeader(2, offset)
	if err != nil {
		return 0, err
	}
	count := 0
	for count < 2 {
		var dataKey []byte
		dataKey, offset, err = decoder.AsStringBytes(offset)
		if err != nil {
			return 0, err
		}
		fieldIndex := -1
		for i, key := range keys {
			if len(dataKey) != len(key) {
				continue
			}
			fieldIndex = i
			for dataKeyIndex := range dataKey {
				if dataKey[dataKeyIndex] != key[dataKeyIndex] {
					fieldIndex = -1
					break
				}
			}
			if fieldIndex >= 0 {
				break
			}
		}
		switch fieldIndex {
		case 0:
			{
				var vv string
				vv, offset, err = decoder.AsString(offset)
				if err != nil {
					return 0, err
				}
				v.Name = vv
			}
			count++
		case 1:
			{
				var vv time.Time
				vv, offset, err = decoder.AsDateTime(offset)
				if err != nil {
					return 0, err
				}
				v.Date = vv
			}
			count++
		default:
			return 0, fmt.Errorf("unknown key[%s] found", string(dataKey))
		}
	}
	return offset, err
}

// calculate size from github.com/eliassebastian/r6index-api/cmd/api/models.ProfileCache
func ___calcArraySizeProfileCache_de2aaf9f1c3e6e79572ba1d8fcf368e421faacf20f265a5b663a07b0680ffe2d(v ProfileCache, encoder *enc.Encoder) (int, error) {
	size := 0
	size += encoder.CalcStructHeaderFix(2)
	size += encoder.CalcInt64(v.LastUpdate)
	if v.Aliases != nil {
		vp := *v.Aliases
		if vp != nil {
			s, err := encoder.CalcSliceLength(len(vp), false)
			if err != nil {
				return 0, err
			}
			size += s
			for _, vpv := range vp {
				size_vpv, err := ___calcArraySizeAlias_de2aaf9f1c3e6e79572ba1d8fcf368e421faacf20f265a5b663a07b0680ffe2d(vpv, encoder)
				if err != nil {
					return 0, err
				}
				size += size_vpv
			}
		} else {
			size += encoder.CalcNil()
		}
	} else {
		size += encoder.CalcNil()
	}
	return size, nil
}

// calculate size from github.com/eliassebastian/r6index-api/cmd/api/models.ProfileCache
func ___calcMapSizeProfileCache_de2aaf9f1c3e6e79572ba1d8fcf368e421faacf20f265a5b663a07b0680ffe2d(v ProfileCache, encoder *enc.Encoder) (int, error) {
	size := 0
	size += encoder.CalcStructHeaderFix(2)
	size += encoder.CalcStringFix(10)
	size += encoder.CalcInt64(v.LastUpdate)
	size += encoder.CalcStringFix(7)
	if v.Aliases != nil {
		vp := *v.Aliases
		if vp != nil {
			s, err := encoder.CalcSliceLength(len(vp), false)
			if err != nil {
				return 0, err
			}
			size += s
			for _, vpv := range vp {
				size_vpv, err := ___calcMapSizeAlias_de2aaf9f1c3e6e79572ba1d8fcf368e421faacf20f265a5b663a07b0680ffe2d(vpv, encoder)
				if err != nil {
					return 0, err
				}
				size += size_vpv
			}
		} else {
			size += encoder.CalcNil()
		}
	} else {
		size += encoder.CalcNil()
	}
	return size, nil
}

// encode from github.com/eliassebastian/r6index-api/cmd/api/models.ProfileCache
func ___encodeArrayProfileCache_de2aaf9f1c3e6e79572ba1d8fcf368e421faacf20f265a5b663a07b0680ffe2d(v ProfileCache, encoder *enc.Encoder, offset int) ([]byte, int, error) {
	var err error
	offset = encoder.WriteStructHeaderFixAsArray(2, offset)
	offset = encoder.WriteInt64(v.LastUpdate, offset)
	if v.Aliases != nil {
		vp := *v.Aliases
		if vp != nil {
			offset = encoder.WriteSliceLength(len(vp), offset, false)
			for _, vpv := range vp {
				_, offset, err = ___encodeArrayAlias_de2aaf9f1c3e6e79572ba1d8fcf368e421faacf20f265a5b663a07b0680ffe2d(vpv, encoder, offset)
				if err != nil {
					return nil, 0, err
				}
			}
		} else {
			offset = encoder.WriteNil(offset)
		}
	} else {
		offset = encoder.WriteNil(offset)
	}
	return encoder.EncodedBytes(), offset, err
}

// encode from github.com/eliassebastian/r6index-api/cmd/api/models.ProfileCache
func ___encodeMapProfileCache_de2aaf9f1c3e6e79572ba1d8fcf368e421faacf20f265a5b663a07b0680ffe2d(v ProfileCache, encoder *enc.Encoder, offset int) ([]byte, int, error) {
	var err error
	offset = encoder.WriteStructHeaderFixAsMap(2, offset)
	offset = encoder.WriteStringFix("LastUpdate", 10, offset)
	offset = encoder.WriteInt64(v.LastUpdate, offset)
	offset = encoder.WriteStringFix("Aliases", 7, offset)
	if v.Aliases != nil {
		vp := *v.Aliases
		if vp != nil {
			offset = encoder.WriteSliceLength(len(vp), offset, false)
			for _, vpv := range vp {
				_, offset, err = ___encodeMapAlias_de2aaf9f1c3e6e79572ba1d8fcf368e421faacf20f265a5b663a07b0680ffe2d(vpv, encoder, offset)
				if err != nil {
					return nil, 0, err
				}
			}
		} else {
			offset = encoder.WriteNil(offset)
		}
	} else {
		offset = encoder.WriteNil(offset)
	}
	return encoder.EncodedBytes(), offset, err
}

// decode to github.com/eliassebastian/r6index-api/cmd/api/models.ProfileCache
func ___decodeArrayProfileCache_de2aaf9f1c3e6e79572ba1d8fcf368e421faacf20f265a5b663a07b0680ffe2d(v *ProfileCache, decoder *dec.Decoder, offset int) (int, error) {
	offset, err := decoder.CheckStructHeader(2, offset)
	if err != nil {
		return 0, err
	}
	{
		var vv int64
		vv, offset, err = decoder.AsInt64(offset)
		if err != nil {
			return 0, err
		}
		v.LastUpdate = vv
	}
	if !decoder.IsCodeNil(offset) {
		var vv []Alias
		var vvl int
		vvl, offset, err = decoder.SliceLength(offset)
		if err != nil {
			return 0, err
		}
		vv = make([]Alias, vvl)
		for vvi := range vv {
			var vvv Alias
			offset, err = ___decodeArrayAlias_de2aaf9f1c3e6e79572ba1d8fcf368e421faacf20f265a5b663a07b0680ffe2d(&vvv, decoder, offset)
			if err != nil {
				return 0, err
			}
			vv[vvi] = vvv
		}
		v.Aliases = &vv
	} else {
		offset++
	}
	return offset, err
}

// decode to github.com/eliassebastian/r6index-api/cmd/api/models.ProfileCache
func ___decodeMapProfileCache_de2aaf9f1c3e6e79572ba1d8fcf368e421faacf20f265a5b663a07b0680ffe2d(v *ProfileCache, decoder *dec.Decoder, offset int) (int, error) {
	keys := [][]byte{
		{uint8(0x4c), uint8(0x61), uint8(0x73), uint8(0x74), uint8(0x55), uint8(0x70), uint8(0x64), uint8(0x61), uint8(0x74), uint8(0x65)}, // LastUpdate
		{uint8(0x41), uint8(0x6c), uint8(0x69), uint8(0x61), uint8(0x73), uint8(0x65), uint8(0x73)},                                        // Aliases
	}
	offset, err := decoder.CheckStructHeader(2, offset)
	if err != nil {
		return 0, err
	}
	count := 0
	for count < 2 {
		var dataKey []byte
		dataKey, offset, err = decoder.AsStringBytes(offset)
		if err != nil {
			return 0, err
		}
		fieldIndex := -1
		for i, key := range keys {
			if len(dataKey) != len(key) {
				continue
			}
			fieldIndex = i
			for dataKeyIndex := range dataKey {
				if dataKey[dataKeyIndex] != key[dataKeyIndex] {
					fieldIndex = -1
					break
				}
			}
			if fieldIndex >= 0 {
				break
			}
		}
		switch fieldIndex {
		case 0:
			{
				var vv int64
				vv, offset, err = decoder.AsInt64(offset)
				if err != nil {
					return 0, err
				}
				v.LastUpdate = vv
			}
			count++
		case 1:
			if !decoder.IsCodeNil(offset) {
				var vv []Alias
				var vvl int
				vvl, offset, err = decoder.SliceLength(offset)
				if err != nil {
					return 0, err
				}
				vv = make([]Alias, vvl)
				for vvi := range vv {
					var vvv Alias
					offset, err = ___decodeMapAlias_de2aaf9f1c3e6e79572ba1d8fcf368e421faacf20f265a5b663a07b0680ffe2d(&vvv, decoder, offset)
					if err != nil {
						return 0, err
					}
					vv[vvi] = vvv
				}
				v.Aliases = &vv
			} else {
				offset++
			}
			count++
		default:
			return 0, fmt.Errorf("unknown key[%s] found", string(dataKey))
		}
	}
	return offset, err
}

// calculate size from github.com/eliassebastian/r6index-api/cmd/api/models.PlayerFound
func ___calcArraySizePlayerFound_de2aaf9f1c3e6e79572ba1d8fcf368e421faacf20f265a5b663a07b0680ffe2d(v PlayerFound, encoder *enc.Encoder) (int, error) {
	size := 0
	size += encoder.CalcStructHeaderFix(3)
	size += encoder.CalcString(v.Message)
	size += encoder.CalcString(v.Nickname)
	size += encoder.CalcString(v.Id)
	return size, nil
}

// calculate size from github.com/eliassebastian/r6index-api/cmd/api/models.PlayerFound
func ___calcMapSizePlayerFound_de2aaf9f1c3e6e79572ba1d8fcf368e421faacf20f265a5b663a07b0680ffe2d(v PlayerFound, encoder *enc.Encoder) (int, error) {
	size := 0
	size += encoder.CalcStructHeaderFix(3)
	size += encoder.CalcStringFix(7)
	size += encoder.CalcString(v.Message)
	size += encoder.CalcStringFix(8)
	size += encoder.CalcString(v.Nickname)
	size += encoder.CalcStringFix(2)
	size += encoder.CalcString(v.Id)
	return size, nil
}

// encode from github.com/eliassebastian/r6index-api/cmd/api/models.PlayerFound
func ___encodeArrayPlayerFound_de2aaf9f1c3e6e79572ba1d8fcf368e421faacf20f265a5b663a07b0680ffe2d(v PlayerFound, encoder *enc.Encoder, offset int) ([]byte, int, error) {
	var err error
	offset = encoder.WriteStructHeaderFixAsArray(3, offset)
	offset = encoder.WriteString(v.Message, offset)
	offset = encoder.WriteString(v.Nickname, offset)
	offset = encoder.WriteString(v.Id, offset)
	return encoder.EncodedBytes(), offset, err
}

// encode from github.com/eliassebastian/r6index-api/cmd/api/models.PlayerFound
func ___encodeMapPlayerFound_de2aaf9f1c3e6e79572ba1d8fcf368e421faacf20f265a5b663a07b0680ffe2d(v PlayerFound, encoder *enc.Encoder, offset int) ([]byte, int, error) {
	var err error
	offset = encoder.WriteStructHeaderFixAsMap(3, offset)
	offset = encoder.WriteStringFix("Message", 7, offset)
	offset = encoder.WriteString(v.Message, offset)
	offset = encoder.WriteStringFix("Nickname", 8, offset)
	offset = encoder.WriteString(v.Nickname, offset)
	offset = encoder.WriteStringFix("Id", 2, offset)
	offset = encoder.WriteString(v.Id, offset)
	return encoder.EncodedBytes(), offset, err
}

// decode to github.com/eliassebastian/r6index-api/cmd/api/models.PlayerFound
func ___decodeArrayPlayerFound_de2aaf9f1c3e6e79572ba1d8fcf368e421faacf20f265a5b663a07b0680ffe2d(v *PlayerFound, decoder *dec.Decoder, offset int) (int, error) {
	offset, err := decoder.CheckStructHeader(3, offset)
	if err != nil {
		return 0, err
	}
	{
		var vv string
		vv, offset, err = decoder.AsString(offset)
		if err != nil {
			return 0, err
		}
		v.Message = vv
	}
	{
		var vv string
		vv, offset, err = decoder.AsString(offset)
		if err != nil {
			return 0, err
		}
		v.Nickname = vv
	}
	{
		var vv string
		vv, offset, err = decoder.AsString(offset)
		if err != nil {
			return 0, err
		}
		v.Id = vv
	}
	return offset, err
}

// decode to github.com/eliassebastian/r6index-api/cmd/api/models.PlayerFound
func ___decodeMapPlayerFound_de2aaf9f1c3e6e79572ba1d8fcf368e421faacf20f265a5b663a07b0680ffe2d(v *PlayerFound, decoder *dec.Decoder, offset int) (int, error) {
	keys := [][]byte{
		{uint8(0x4d), uint8(0x65), uint8(0x73), uint8(0x73), uint8(0x61), uint8(0x67), uint8(0x65)},              // Message
		{uint8(0x4e), uint8(0x69), uint8(0x63), uint8(0x6b), uint8(0x6e), uint8(0x61), uint8(0x6d), uint8(0x65)}, // Nickname
		{uint8(0x49), uint8(0x64)}, // Id
	}
	offset, err := decoder.CheckStructHeader(3, offset)
	if err != nil {
		return 0, err
	}
	count := 0
	for count < 3 {
		var dataKey []byte
		dataKey, offset, err = decoder.AsStringBytes(offset)
		if err != nil {
			return 0, err
		}
		fieldIndex := -1
		for i, key := range keys {
			if len(dataKey) != len(key) {
				continue
			}
			fieldIndex = i
			for dataKeyIndex := range dataKey {
				if dataKey[dataKeyIndex] != key[dataKeyIndex] {
					fieldIndex = -1
					break
				}
			}
			if fieldIndex >= 0 {
				break
			}
		}
		switch fieldIndex {
		case 0:
			{
				var vv string
				vv, offset, err = decoder.AsString(offset)
				if err != nil {
					return 0, err
				}
				v.Message = vv
			}
			count++
		case 1:
			{
				var vv string
				vv, offset, err = decoder.AsString(offset)
				if err != nil {
					return 0, err
				}
				v.Nickname = vv
			}
			count++
		case 2:
			{
				var vv string
				vv, offset, err = decoder.AsString(offset)
				if err != nil {
					return 0, err
				}
				v.Id = vv
			}
			count++
		default:
			return 0, fmt.Errorf("unknown key[%s] found", string(dataKey))
		}
	}
	return offset, err
}
